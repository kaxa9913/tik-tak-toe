# tik-tak-toe
Техническая документация: Игра "Крестики-нолики" с компьютерным противником

1. Общее описание
Проект представляет собой реализацию игры в крестики-нолики для двух игроков: человека и компьютера. Игровое поле имеет размер 3x3, и победителем считается тот, кто первым выстроит три своих символа в ряд (по горизонтали, вертикали или диагонали). Компьютер может играть на трех уровнях сложности:
- Легкий (случайные ходы),
- Средний (блокирует победу игрока или делает случайный ход),
- Сложный (использует алгоритм минимакс для оптимального выбора хода).



2. Структура проекта

Глобальные переменные
- `board[3][3]` — массив, представляющий игровое поле. Каждая ячейка может содержать:
 - `' '` (пробел) — пустая клетка,
 - `'X'` — символ игрока,
  - `'O'` — символ компьютера.
- `PLAYER` — символ игрока (например, `'X'`).
- `COMPUTER` — символ компьютера (например, `'O'`).
- `difficulty` — уровень сложности компьютера (1 — легкий, 2 — средний, 3 — сложный).



 2.1Функции

  `void printBoard()`
Описание:
Отображает текущее состояние игрового поля в консоль.

Алгоритм:
1. Выводится верхняя граница поля (`-------------`).
2. Для каждой строки игрового поля:
   - Выводится строка в формате `| X | O |   |`, где `X`, `O` или пробел соответствуют состоянию ячеек.
   - После каждой строки выводится разделительная линия.



 `bool isMovesLeft()`
Описание:  
Проверяет, остались ли свободные клетки на игровом поле.

Алгоритм:
1. Проходится по всем ячейкам массива `board`.
2. Если хотя бы одна ячейка содержит `' '`, возвращается `true`.
3. Если все ячейки заняты, возвращается `false`.



 `bool makeMove(int row, int col, char player)`
Описание:  
Выполняет ход игрока или компьютера, если выбранная клетка свободна.

Параметры:
- `row` — номер строки (от 0 до 2).
- `col` — номер столбца (от 0 до 2).
- `player` — символ игрока (`'X'` или `'O'`).

Алгоритм:
1. Проверяется, свободна ли ячейка `board[row][col]`.
2. Если ячейка свободна:
   - Записывается символ игрока в ячейку.
   - Возвращается `true`.
3. Если ячейка занята, возвращается `false`.



 `void playerMove()`
Описание:
Обрабатывает ход игрока, запрашивая координаты клетки.

Алгоритм:
1. В цикле запрашиваются у игрока координаты клетки (строка и столбец).
2. Вызывается функция `makeMove()` для проверки корректности хода.
3. Если ход успешен, цикл завершается. Если нет, выводится сообщение об ошибке.

---

  `char checkWinner()`
Описание: 
Проверяет, есть ли победитель на текущем этапе игры.

Алгоритм:
1. Проверяются все строки, столбцы и диагонали:
   - Если три ячейки в ряду, столбце или диагонали содержат одинаковый символ (`'X'` или `'O'`), возвращается этот символ.
2. Если победителя нет, возвращается `' '` (пробел).



  `int evaluate()`
Описание:
Оценивает текущую ситуацию на игровом поле.

Алгоритм:
1. Вызывается функция `checkWinner()` для проверки победителя.
2. Если победил компьютер, возвращается `+10`.
3. Если победил игрок, возвращается `-10`.
4. Если победителя нет, возвращается `0`.



 `int minimax(bool isMax)`
Описание:
Реализует алгоритм минимакс для выбора оптимального хода компьютера.

Параметры:
- `isMax` — флаг, указывающий, максимизирует ли текущий игрок свой результат (`true` для компьютера, `false` для игрока).

Алгоритм:
1. Вычисляется текущая оценка поля с помощью функции `evaluate()`.
2. Если игра завершена (есть победитель или ничья), возвращается оценка.
3. Если `isMax == true` (ход компьютера):
   - Перебираются все возможные ходы.
   - Для каждого хода рекурсивно вызывается `minimax()` с флагом `false`.
   - Выбирается ход с максимальной оценкой.
4. Если `isMax == false` (ход игрока):
   - Перебираются все возможные ходы.
   - Для каждого хода рекурсивно вызывается `minimax()` с флагом `true`.
   - Выбирается ход с минимальной оценкой.



  `void computerMove()`
Описание:
Обрабатывает ход компьютера в зависимости от уровня сложности.

Алгоритм:
1. Легкий уровень (`difficulty == 1`):
   - Выбирается случайная свободная клетка.
2. Средний уровень (`difficulty == 2`):
   - Проверяется, можно ли заблокировать победу игрока.
   - Если блокировка невозможна, выбирается случайная клетка.
3. Сложный уровень (`difficulty == 3`):
   - Используется алгоритм минимакс для выбора оптимального хода.



 `void start()`
Описание:  
Запускает игровой цикл.

Алгоритм:
1. Отображается начальное состояние игрового поля.
2. В бесконечном цикле чередуются ходы игрока и компьютера:
   - После каждого хода проверяется наличие победителя или ничьи.
   - Если игра завершена, цикл прерывается.
3. Выводится сообщение о результате игры (победа игрока, победа компьютера или ничья).



 3. Пример использования
1. Установите уровень сложности (`difficulty = 1`, `2` или `3`).
2. Запустите функцию `start()`.
3. Игрок вводит координаты клетки для своего хода.
4. Компьютер выполняет ход в соответствии с выбранным уровнем сложности.
5. Игра продолжается до победы одного из участников или ничьей.



4. Возможные улучшения
1. Добавить графический интерфейс для более удобного взаимодействия.
2. Реализовать возможность изменения размера игрового поля (например, 4x4 или 5x5).
3. Добавить поддержку нескольких режимов игры (например, два игрока или сетевая игра).
4. Улучшить алгоритм минимакс с использованием альфа-бета отсечения для повышения производительности.



5. Заключение
Данный проект предоставляет базовую реализацию игры в крестики-нолики с компьютерным противником. Благодаря гибкости кода и использованию алгоритма минимакс, игра предлагает разнообразие уровней сложности и демонстрирует основы искусственного интеллекта в простых играх.
6. Показ игры 
(https://github.com/user-attachments/assets/921117fe-6c94-4332-8f89-b6db99e21511)

#include <iostream>
#include <vector>
#include <limits>
#include <cstdlib>
#include <ctime>

using namespace std;

const char PLAYER = 'X'; // Символ игрока
const char COMPUTER = 'O'; // Символ компьютера
int difficulty = 1; // Уровень сложности

class Game {
private:
    vector<vector<char>> board; // Игровое поле

public:
    // Конструктор: инициализация пустого поля
    Game() {
        board = vector<vector<char>>(3, vector<char>(3, ' '));
    }

    // Метод для отображения текущего состояния поля
    void printBoard() {
        cout << "-------------\n";
        for (int i = 0; i < 3; i++) {
            cout << "| ";
            for (int j = 0; j < 3; j++) {
                cout << board[i][j] << " | ";
            }
            cout << "\n-------------\n";
        }
    }

    // Проверка есть ли свободные клетки
    bool isMovesLeft() {
        for (auto& row : board)
            for (auto cell : row)
                if (cell == ' ') return true;
        return false;
    }

    // Сделать ход, если клетка свободна
    bool makeMove(int row, int col, char player) {
        if (row >= 0 && row < 3 && col >= 0 && col < 3 && board[row][col] == ' ') {
            board[row][col] = player;
            return true;
        }
        return false;
    }

    // Обработка хода игрока с проверкой корректности
    void playerMove() {
        int row, col;
        while (true) {
            cout << "Введите ваш ход (строка и столбец от 0 до 2): ";
            cin >> row >> col;
            if (makeMove(row, col, PLAYER)) break;
            cout << "Неверный ход, попробуйте снова.\n";
        }
    }

    // Проверка текущего состояния поля на победителя
    char checkWinner() {
        // Проверка строк и столбцов
        for (int i = 0; i < 3; i++) {
            if (board[i][0] != ' ' &&
                board[i][0] == board[i][1] &&
                board[i][1] == board[i][2])
                return board[i][0];

            if (board[0][i] != ' ' &&
                board[0][i] == board[1][i] &&
                board[1][i] == board[2][i])
                return board[0][i];
        }

        // Проверка диагоналей
        if (board[0][0] != ' ' &&
            board[0][0] == board[1][1] &&
            board[1][1] == board[2][2])
            return board[0][0];

        if (board[0][2] != ' ' &&
            board[0][2] == board[1][1] &&
            board[1][1] == board[2][0])
            return board[0][2];

        // Нет победителя
        return ' ';
    }

    // Оценка состояния поля для алгоритма minimax
    int evaluate() {
        char winner = checkWinner();
        if (winner == COMPUTER) return +10; // Выигрыш компьютера
        else if (winner == PLAYER) return -10; // Выигрыш игрока
        else return 0; // Ничья или игра продолжается
    }

    // Реализация алгоритма minimax
    int minimax(bool isMax) {
        int score = evaluate();

        // Если есть победитель, вернуть соответствующий результат
        if (score == 10 || score == -10) return score;

        // Если ходов не осталось, ничья
        if (!isMovesLeft()) return 0;

        if (isMax) {
            int best = -1000; // Инициализация минимально возможным
            // Перебор всех пустых клеток для поиска лучшего хода
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (board[i][j] == ' ') {
                        board[i][j] = COMPUTER; // Сделать ход компьютера
                        best = max(best, minimax(!isMax)); // Рекурсия
                        board[i][j] = ' '; // Отменить ход
                    }
            return best;
        } else {
            int best = 1000; // Инициализация максимально возможным
            // Перебор всех пустых клеток для поиска худшего для компьютера варианта
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (board[i][j] == ' ') {
                        board[i][j] = PLAYER; // Сделать ход игрока
                        best = min(best, minimax(!isMax)); // Рекурсия
                        board[i][j] = ' '; // Отменить ход
                    }
            return best;
        }
    }

    // Логика выбора хода компьютера в зависимости от уровня сложности
    void computerMove() {
        int bestVal = -1000;
        int bestRow = -1, bestCol = -1;

        if (difficulty == 1) { // Легкий уровень - случайный ход
            vector<pair<int, int>> moves;
            for (int i = 0; i < 3; ++i)
                for (int j = 0; j < 3; ++j)
                    if (board[i][j] == ' ')
                        moves.push_back({i, j});
            if (!moves.empty()) {
                srand(time(0));
                auto move = moves[rand() % moves.size()];
                makeMove(move.first, move.second, COMPUTER);
            }
        }

        else if (difficulty == 2) { // Средний уровень - блокировать или делать случайный ход
            bool moveMade = false;

            // Попытка заблокировать победу игрока
            for (int i = 0; i < 3 && !moveMade; ++i) {
                for (int j = 0; j < 3 && !moveMade; ++j) {
                    if (board[i][j] == ' ') {
                        // Проверка, если поставим сюда игрока, может выиграть
                        board[i][j] = PLAYER;
                        if (checkWinner() == PLAYER) {
                            // Блокируем
                            board[i][j] = COMPUTER;
                            moveMade = true;
                            break;
                        }
                        // Возвращение назад
                        board[i][j] = ' ';
                    }
                }
            }

            // Если не удалось блокировать, делаем случайный ход
            if (!moveMade) {
                vector<pair<int, int>> freeMoves;
                for (int i = 0; i < 3; ++i)
                    for (int j = 0; j < 3; ++j)
                        if (board[i][j] == ' ')
                            freeMoves.push_back({i, j});
                if (!freeMoves.empty()) {
                    srand(time(0));
                    auto move = freeMoves[rand() % freeMoves.size()];
                    makeMove(move.first, move.second, COMPUTER);
                }
            }
        }

        else if (difficulty == 3) { // Сложный уровень - алгоритм minimax
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (board[i][j] == ' ') {
                        board[i][j] = COMPUTER;
                        int moveVal = minimax(false);
                        board[i][j] = ' ';
                        if (moveVal > bestVal) {
                            bestRow = i;
                            bestCol = j;
                            bestVal = moveVal;
                        }
                    }
            // Сделать оптимальный ход
            makeMove(bestRow, bestCol, COMPUTER);
        }
    }

    // Основной цикл игры
    void start() {
        printBoard();
        while (true) {
            playerMove(); // Ход игрока
            printBoard();
            if (checkWinner() == PLAYER) { // Проверка победы игрока
                cout << "Вы победили!\n";
                break;
            }
            if (!isMovesLeft()) { // Если ходов не осталось, ничья
                cout << "Ничья!\n";
                break;
            }

            cout << "Ход компьютера...\n";
            computerMove(); // Ход компьютера
            printBoard();
            if (checkWinner() == COMPUTER) { // Проверка победы компьютера
                cout << "Вы проиграли.\n";
                break;
            }
            if (!isMovesLeft()) { // Если ходов не осталось, ничья
                cout << "Ничья!\n";
                break;
            }
        }
    }
};

int main() {
    cout << "=== КРЕСТИКИ-НОЛИКИ ===\n";
    cout << "Выберите уровень сложности:\n";
    cout << "1 - Лёгкий\n2 - Средний\n3 - Сложный\n";
    cin >> difficulty;

    Game game;
    game.start();

    return 0;
}
