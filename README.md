# tik-tak-toe
Техническая документация: Игра "Крестики-нолики" с компьютерным противником

1. Общее описание
Проект представляет собой реализацию игры в крестики-нолики для двух игроков: человека и компьютера. Игровое поле имеет размер 3x3, и победителем считается тот, кто первым выстроит три своих символа в ряд (по горизонтали, вертикали или диагонали). Компьютер может играть на трех уровнях сложности:
- Легкий (случайные ходы),
- Средний (блокирует победу игрока или делает случайный ход),
- Сложный (использует алгоритм минимакс для оптимального выбора хода).



2. Структура проекта

Глобальные переменные
- `board[3][3]` — массив, представляющий игровое поле. Каждая ячейка может содержать:
 - `' '` (пробел) — пустая клетка,
 - `'X'` — символ игрока,
  - `'O'` — символ компьютера.
- `PLAYER` — символ игрока (например, `'X'`).
- `COMPUTER` — символ компьютера (например, `'O'`).
- `difficulty` — уровень сложности компьютера (1 — легкий, 2 — средний, 3 — сложный).



 2.1Функции

  `void printBoard()`
Описание:
Отображает текущее состояние игрового поля в консоль.

Алгоритм:
1. Выводится верхняя граница поля (`-------------`).
2. Для каждой строки игрового поля:
   - Выводится строка в формате `| X | O |   |`, где `X`, `O` или пробел соответствуют состоянию ячеек.
   - После каждой строки выводится разделительная линия.



 `bool isMovesLeft()`
Описание:  
Проверяет, остались ли свободные клетки на игровом поле.

Алгоритм:
1. Проходится по всем ячейкам массива `board`.
2. Если хотя бы одна ячейка содержит `' '`, возвращается `true`.
3. Если все ячейки заняты, возвращается `false`.



 `bool makeMove(int row, int col, char player)`
Описание:  
Выполняет ход игрока или компьютера, если выбранная клетка свободна.

Параметры:
- `row` — номер строки (от 0 до 2).
- `col` — номер столбца (от 0 до 2).
- `player` — символ игрока (`'X'` или `'O'`).

Алгоритм:
1. Проверяется, свободна ли ячейка `board[row][col]`.
2. Если ячейка свободна:
   - Записывается символ игрока в ячейку.
   - Возвращается `true`.
3. Если ячейка занята, возвращается `false`.



 `void playerMove()`
Описание:
Обрабатывает ход игрока, запрашивая координаты клетки.

Алгоритм:
1. В цикле запрашиваются у игрока координаты клетки (строка и столбец).
2. Вызывается функция `makeMove()` для проверки корректности хода.
3. Если ход успешен, цикл завершается. Если нет, выводится сообщение об ошибке.

---

  `char checkWinner()`
Описание: 
Проверяет, есть ли победитель на текущем этапе игры.

Алгоритм:
1. Проверяются все строки, столбцы и диагонали:
   - Если три ячейки в ряду, столбце или диагонали содержат одинаковый символ (`'X'` или `'O'`), возвращается этот символ.
2. Если победителя нет, возвращается `' '` (пробел).



  `int evaluate()`
Описание:
Оценивает текущую ситуацию на игровом поле.

Алгоритм:
1. Вызывается функция `checkWinner()` для проверки победителя.
2. Если победил компьютер, возвращается `+10`.
3. Если победил игрок, возвращается `-10`.
4. Если победителя нет, возвращается `0`.



 `int minimax(bool isMax)`
Описание:
Реализует алгоритм минимакс для выбора оптимального хода компьютера.

Параметры:
- `isMax` — флаг, указывающий, максимизирует ли текущий игрок свой результат (`true` для компьютера, `false` для игрока).

Алгоритм:
1. Вычисляется текущая оценка поля с помощью функции `evaluate()`.
2. Если игра завершена (есть победитель или ничья), возвращается оценка.
3. Если `isMax == true` (ход компьютера):
   - Перебираются все возможные ходы.
   - Для каждого хода рекурсивно вызывается `minimax()` с флагом `false`.
   - Выбирается ход с максимальной оценкой.
4. Если `isMax == false` (ход игрока):
   - Перебираются все возможные ходы.
   - Для каждого хода рекурсивно вызывается `minimax()` с флагом `true`.
   - Выбирается ход с минимальной оценкой.



  `void computerMove()`
Описание:
Обрабатывает ход компьютера в зависимости от уровня сложности.

Алгоритм:
1. Легкий уровень (`difficulty == 1`):
   - Выбирается случайная свободная клетка.
2. Средний уровень (`difficulty == 2`):
   - Проверяется, можно ли заблокировать победу игрока.
   - Если блокировка невозможна, выбирается случайная клетка.
3. Сложный уровень (`difficulty == 3`):
   - Используется алгоритм минимакс для выбора оптимального хода.



 `void start()`
Описание:  
Запускает игровой цикл.

Алгоритм:
1. Отображается начальное состояние игрового поля.
2. В бесконечном цикле чередуются ходы игрока и компьютера:
   - После каждого хода проверяется наличие победителя или ничьи.
   - Если игра завершена, цикл прерывается.
3. Выводится сообщение о результате игры (победа игрока, победа компьютера или ничья).



 3. Пример использования
1. Установите уровень сложности (`difficulty = 1`, `2` или `3`).
2. Запустите функцию `start()`.
3. Игрок вводит координаты клетки для своего хода.
4. Компьютер выполняет ход в соответствии с выбранным уровнем сложности.
5. Игра продолжается до победы одного из участников или ничьей.



4. Возможные улучшения
1. Добавить графический интерфейс для более удобного взаимодействия.
2. Реализовать возможность изменения размера игрового поля (например, 4x4 или 5x5).
3. Добавить поддержку нескольких режимов игры (например, два игрока или сетевая игра).
4. Улучшить алгоритм минимакс с использованием альфа-бета отсечения для повышения производительности.



5. Заключение
Данный проект предоставляет базовую реализацию игры в крестики-нолики с компьютерным противником. Благодаря гибкости кода и использованию алгоритма минимакс, игра предлагает разнообразие уровней сложности и демонстрирует основы искусственного интеллекта в простых играх.
6. Показ игры 
(https://github.com/user-attachments/assets/921117fe-6c94-4332-8f89-b6db99e21511)

#include <iostream>
#include <vector>
#include <limits>
#include <cstdlib>
#include <ctime>

using namespace std;

const char PLAYER = 'X';
const char COMPUTER = 'O';
int difficulty = 1;

class Game {
private:
    vector<vector<char>> board;

public:
    Game() {
        board = vector<vector<char>>(3, vector<char>(3, ' '));
    }

    void printBoard() {
        cout << "-------------\n";
        for (int i = 0; i < 3; i++) {
            cout << "| ";
            for (int j = 0; j < 3; j++) {
                cout << board[i][j] << " | ";
            }
            cout << "\n-------------\n";
        }
    }

    bool isMovesLeft() {
        for (auto& row : board)
            for (auto cell : row)
                if (cell == ' ') return true;
        return false;
    }

    bool makeMove(int row, int col, char player) {
        if (row >= 0 && row < 3 && col >= 0 && col < 3 && board[row][col] == ' ') {
            board[row][col] = player;
            return true;
        }
        return false;
    }

    void playerMove() {
        int row, col;
        while (true) {
            cout << "Введите ваш ход (строка и столбец от 0 до 2): ";
            cin >> row >> col;
            if (makeMove(row, col, PLAYER)) break;
            cout << "Неверный ход, попробуйте снова.\n";
        }
    }

    char checkWinner() {
        // Проверка по строкам, столбцам и диагоналям
        for (int i = 0; i < 3; i++) {
            if (board[i][0] != ' ' &&
                board[i][0] == board[i][1] &&
                board[i][1] == board[i][2])
                return board[i][0];

            if (board[0][i] != ' ' &&
                board[0][i] == board[1][i] &&
                board[1][i] == board[2][i])
                return board[0][i];
        }

        if (board[0][0] != ' ' &&
            board[0][0] == board[1][1] &&
            board[1][1] == board[2][2])
            return board[0][0];

        if (board[0][2] != ' ' &&
            board[0][2] == board[1][1] &&
            board[1][1] == board[2][0])
            return board[0][2];

        return ' ';
    }

    int evaluate() {
        char winner = checkWinner();
        if (winner == COMPUTER) return +10;
        else if (winner == PLAYER) return -10;
        else return 0;
    }

    int minimax(bool isMax) {
        int score = evaluate();
        if (score == 10 || score == -10) return score;
        if (!isMovesLeft()) return 0;

        if (isMax) {
            int best = -1000;
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (board[i][j] == ' ') {
                        board[i][j] = COMPUTER;
                        best = max(best, minimax(!isMax));
                        board[i][j] = ' ';
                    }
            return best;
        } else {
            int best = 1000;
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (board[i][j] == ' ') {
                        board[i][j] = PLAYER;
                        best = min(best, minimax(!isMax));
                        board[i][j] = ' ';
                    }
            return best;
        }
    }

    void computerMove() {
        int bestVal = -1000;
        int bestRow = -1, bestCol = -1;

        if (difficulty == 1) { // Легкий: случайный ход
            vector<pair<int, int>> moves;
            for (int i = 0; i < 3; ++i)
                for (int j = 0; j < 3; ++j)
                    if (board[i][j] == ' ')
                        moves.push_back({i, j});
            if (!moves.empty()) {
                srand(time(0));
                auto move = moves[rand() % moves.size()];
                makeMove(move.first, move.second, COMPUTER);
            }
        }

        else if (difficulty == 2) { // Средний: блокировать или делать случайный ход
            bool moveMade = false;

            // Попытка заблокировать игрока, если он может выиграть следующим ходом
            for (int i = 0; i < 3 && !moveMade; ++i) {
                for (int j = 0; j < 3 && !moveMade; ++j) {
                    if (board[i][j] == ' ') {
                        // Проверяем, если поставим здесь игрока, проиграет ли он
                        board[i][j] = PLAYER;
                        if (checkWinner() == PLAYER) {
                            // Тогда делаем ход компьютером сюда
                            board[i][j] = COMPUTER;
                            moveMade = true;
                            break;
                        }
                        // Возвращаем назад
                        board[i][j] = ' ';
                    }
                }
            }

            if (!moveMade) {
                // Если не удалось блокировать, выбираем случайный ход
                vector<pair<int, int>> freeMoves;
                for (int i = 0; i < 3; ++i)
                    for (int j = 0; j < 3; ++j)
                        if (board[i][j] == ' ')
                            freeMoves.push_back({i, j});
                if (!freeMoves.empty()) {
                    srand(time(0));
                    auto move = freeMoves[rand() % freeMoves.size()];
                    makeMove(move.first, move.second, COMPUTER);
                }
            }
        }

        else if (difficulty == 3) { // Сложный: minimax
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (board[i][j] == ' ') {
                        board[i][j] = COMPUTER;
                        int moveVal = minimax(false);
                        board[i][j] = ' ';
                        if (moveVal > bestVal) {
                            bestRow = i;
                            bestCol = j;
                            bestVal = moveVal;
                        }
                    }
            makeMove(bestRow, bestCol, COMPUTER);
        }
    }

    void start() {
        printBoard();
        while (true) {
            playerMove();
            printBoard();
            if (checkWinner() == PLAYER) {
                cout << "Вы победили!\n";
                break;
            }
            if (!isMovesLeft()) {
                cout << "Ничья!\n";
                break;
            }

            cout << "Ход компьютера...\n";
            computerMove();
            printBoard();
            if (checkWinner() == COMPUTER) {
                cout << "Вы проиграли.\n";
                break;
            }
            if (!isMovesLeft()) {
                cout << "Ничья!\n";
                break;
            }
        }
    }
};

int main() {
    cout << "=== КРЕСТИКИ-НОЛИКИ ===\n";
    cout << "Выберите уровень сложности:\n";
    cout << "1 - Лёгкий\n2 - Средний\n3 - Сложный\n";
    cin >> difficulty;

    Game game;
    game.start();

    return 0;
}
